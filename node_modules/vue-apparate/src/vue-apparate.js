/*! Pertains to scrolling element code:
https://mths.be/scrollingelement v1.5.2 by @diegoperini & @mathias | MIT license */
if (!('scrollingElement' in document)) (function() {

	function computeStyle(element) {
		if (window.getComputedStyle) {
			// Support Firefox < 4 which throws on a single parameter.
			return getComputedStyle(element, null);
		}
		// Support Internet Explorer < 9.
		return element.currentStyle;
	}

	function isBodyElement(element) {
		// The `instanceof` check gives the correct result for e.g. `body` in a
		// non-HTML namespace.
		if (window.HTMLBodyElement) {
			return element instanceof HTMLBodyElement;
		}
		// Fall back to a `tagName` check for old browsers.
		return /body/i.test(element.tagName);
	}

	function getNextBodyElement(frameset) {
		// We use this function to be correct per spec in case `document.body` is
		// a `frameset` but there exists a later `body`. Since `document.body` is
		// a `frameset`, we know the root is an `html`, and there was no `body`
		// before the `frameset`, so we just need to look at siblings after the
		// `frameset`.
		var current = frameset;
		while (current = current.nextSibling) {
			if (current.nodeType == 1 && isBodyElement(current)) {
				return current;
			}
		}
		// No `body` found.
		return null;
	}

	// Note: standards mode / quirks mode can be toggled at runtime via
	// `document.write`.
	var isCompliantCached;
	var isCompliant = function() {
		var isStandardsMode = /^CSS1/.test(document.compatMode);
		if (!isStandardsMode) {
			// In quirks mode, the result is equivalent to the non-compliant
			// standards mode behavior.
			return false;
		}
		if (isCompliantCached === void 0) {
			// When called for the first time, check whether the browser is
			// standard-compliant, and cache the result.
			var iframe = document.createElement('iframe');
			iframe.style.height = '1px';
			(document.body || document.documentElement || document).appendChild(iframe);
			var doc = iframe.contentWindow.document;
			doc.write('<!DOCTYPE html><div style="height:9999em">x</div>');
			doc.close();
			isCompliantCached = doc.documentElement.scrollHeight > doc.body.scrollHeight;
			iframe.parentNode.removeChild(iframe);
		}
		return isCompliantCached;
	};

	function isRendered(style) {
		return style.display != 'none' && !(style.visibility == 'collapse' &&
			/^table-(.+-group|row|column)$/.test(style.display));
	}

	function isScrollable(body) {
		// A `body` element is scrollable if `body` and `html` both have
		// non-`visible` overflow and are both being rendered.
		var bodyStyle = computeStyle(body);
		var htmlStyle = computeStyle(document.documentElement);
		return bodyStyle.overflow != 'visible' && htmlStyle.overflow != 'visible' &&
			isRendered(bodyStyle) && isRendered(htmlStyle);
	}

	var scrollingElement = function() {
		if (isCompliant()) {
			return document.documentElement;
		}
		var body = document.body;
		// Note: `document.body` could be a `frameset` element, or `null`.
		// `tagName` is uppercase in HTML, but lowercase in XML.
		var isFrameset = body && !/body/i.test(body.tagName);
		body = isFrameset ? getNextBodyElement(body) : body;
		// If `body` is itself scrollable, it is not the `scrollingElement`.
		return body && isScrollable(body) ? null : body;
	};

	if (Object.defineProperty) {
		// Support modern browsers that lack a native implementation.
		Object.defineProperty(document, 'scrollingElement', {
			'get': scrollingElement
		});
	} else if (document.__defineGetter__) {
		// Support Firefox ≤ 3.6.9, Safari ≤ 4.1.3.
		document.__defineGetter__('scrollingElement', scrollingElement);
	} else {
		// IE ≤ 4 lacks `attachEvent`, so it only gets this one assignment. IE ≤ 7
		// gets it too, but the value is updated later (see `propertychange`).
		document.scrollingElement = scrollingElement();
		document.attachEvent && document.attachEvent('onpropertychange', function() {
			// This is for IE ≤ 7 only.
			// A `propertychange` event fires when `<body>` is parsed because
			// `document.activeElement` then changes.
			if (window.event.propertyName == 'activeElement') {
				document.scrollingElement = scrollingElement();
			}
		});
	}
}());

/*
Pertains to functions isObject:

Copyright JS Foundation and other contributors <https://js.foundation/>

Based on Underscore.js, copyright Jeremy Ashkenas,
DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>

This software consists of voluntary contributions made by many
individuals. For exact contribution history, see the revision history
available at https://github.com/lodash/lodash
*/

function isObject(value) {
  const type = typeof value
  return value != null && (type == 'object' || type == 'function')
}

window.VueApparate = {
  init(Vue) {
    var that = this
    Vue.directive('apparate', {
      inserted(el, binding) {
        if(isObject(binding.value)) {
          var y = binding.value.y,
            delay = binding.value.delay

					var appendApparateClass = typeof binding.value.appendApparateClass === 'undefined' ? true : binding.value.appendApparateClass

        } else {
          var y = 0,
            delay = 0
        }

          Vue.nextTick(() => {
            that.apparatorConstructor(el, binding.arg, y, delay, appendApparateClass)
            that.checkForReadyApparators()
          })
      }
    })

    this.apparatorArray = []
    this.apparatorsPresent = false

    setInterval(() => {
      this.checkForApparatorsPresent()
    }, 50)
  },

  // if apparators are present, check if they're still present
  // if they are, do nothing. If they aren't, stop the interval
  // to increase performance. If apparators AREN'T present, check if they
  // now are. If yes, start checking the scroll distance again.
  checkForApparatorsPresent() {
    if (this.apparatorsPresent) {
      if (this.apparatorArray.length === 0) {
        this.clearScrollDistanceCheckInterval()
        this.apparatorsPresent = false
      }
    } else if (!this.apparatorsPresent) {
      if (this.apparatorArray.length > 0) {
        this.startCheckingScrollDistance()
        this.apparatorsPresent = true
      }
    }
  },

  startCheckingScrollDistance() {
    this.scrollDistanceCheck = setInterval(() => {
      if (this.apparatorsPresent) {
        this.checkForReadyApparators()
      }
    }, 50)
  },

  clearScrollDistanceCheckInterval() {
    clearInterval(this.scrollDistanceCheck)
  },

  apparatorArraySorter(a, b) {
    // we define a custom sorter function here because
    // Array.prototype.sort will convert numbers to strings
    // using it's default sorter. Seems like not a big deal
    // except 80 is smaller than 8 in unicode, so our Array
    // will be all messed up. See the docs for sort() for
    // more info
    return a.yOffset - b.yOffset
  },

  getPositionOfEl(el) {
    let yPosition = 0

    while (el) {
      yPosition += (el.offsetTop + el.clientTop)
      el = el.offsetParent
    }
    return yPosition
  },

  apparatorConstructor(el, classToAdd, extraYOffset, apparationDelay, appendApparateClass) {
		if (appendApparateClass) {
			el.className += ' apparate'
		}

    if (typeof extraYOffset === "number") {
      var extra = extraYOffset
    } else {
      var extra = 0
    }

    if (typeof apparationDelay === "number") {
      var delay = apparationDelay
    } else {
      var delay = 0
    }

    let yOffset = this.getPositionOfEl(el) + extra
    this.apparatorArray.push({el, yOffset, classToAdd, apparationDelay})
    this.apparatorArray.sort(this.apparatorArraySorter)
  },

  apparatorRemover(apparator) {
    let index = this.apparatorArray.indexOf(apparator)
    this.apparatorArray.splice(index, 1)
  },

  checkForReadyApparators() {
    for (var i = 0; i < this.apparatorArray.length; i++) {
      let target = this.apparatorArray[i].yOffset,
        scrollDistanceBottom = document.scrollingElement.scrollTop + window.innerHeight

      if (target <= scrollDistanceBottom) {
        this.apparate(this.apparatorArray[i])
      } else {
        // since the apparators are sorted by distance from top
        // if one of them isn't ready, the remaining aren't either
        // so we break the for loop
        i = this.apparatorArray.length
      }
    }
  },

  apparate(apparator) {
    this.apparatorRemover(apparator)
    setTimeout(() => {
      apparator.el.className += ` ${apparator.classToAdd}`
    }, apparator.apparationDelay)
  }
}
